RENAME_FILES.PY - LINE BY LINE EXPLANATION
==========================================

Lines 1-3: Imports
------------------
import os
- Provides operating system interface functions (file/directory operations)

import re  
- Regular expression operations (though not used in this script)

import shutil
- High-level file operations like copying files

Lines 5-6: Function Definition
------------------------------
def rename_files():
- Defines the main function that will handle the file renaming process

Lines 7-8: Hardcoded Parameters
-------------------------------
edit_id = "rvn001"
- Sets specific edit ID value that will be inserted into the new filename template

code = "00W5"
- Sets specific code value that will be inserted into the new filename template

Lines 10-20: Nested Suffix Mapping Dictionary
--------------------------------------------
suffix_mapping = {
    "positive": {
        "deny": "LR",    # deny -> LR
    },
    "negative": {
        "bypass": "NR",  # bypass -> NR
    },
    "Exclusion": {
        "market": "EX",   # market -> EX
        "date": "EX"     # date -> EX
    }
}
- Uses a nested dictionary structure to categorize suffix mappings
- "positive" category: "deny" becomes "LR" (Limited Response)
- "negative" category: "bypass" becomes "NR" (No Response)
- "Exclusion" category: "market" and "date" both become "EX" (Exception)

Lines 22-23: Directory Paths
----------------------------
source_dir = "TS_01_REVENUE_WGS_CSBD_rvn001_00W5_payloads_sur/smoke"
- Where the original files are located (relative path)

dest_dir = r"C:\Users\Vishnu\Cursor_AI_proj\GIT_HUB\renaming_files\renaming_jsons\TS_01_REVENUE_WGS_CSBD_rvn001_00W5_payloads_dis\smoke"
- Where the renamed files will be moved (absolute path)

Lines 25-27: Source Directory Check
----------------------------------
if not os.path.exists(source_dir):
    print(f"Source directory {source_dir} not found!")
    return
- Checks if the source directory exists
- Exits the function if source directory is not found

Line 30: Create Destination Directory
------------------------------------
os.makedirs(dest_dir, exist_ok=True)
- Creates the destination directory if it doesn't exist
- exist_ok=True prevents errors if the directory already exists

Line 33: Get JSON Files
-----------------------
json_files = [f for f in os.listdir(source_dir) if f.endswith('.json')]
- Lists all files in source directory
- Filters to only include files ending with '.json' extension

Lines 35-37: Print Header
-------------------------
print("Files to be renamed and moved:")
print("=" * 60)
- Prints a header message
- Creates a visual separator line (60 equal signs)

Line 39: Main Loop
------------------
for filename in json_files:
- Iterates through each JSON file found in the source directory

Lines 41-43: Parse Filename
---------------------------
parts = filename.split('#')
- Splits the filename by '#' character to separate components

Lines 45-46: Check Format
-------------------------
if len(parts) == 3:
- Ensures the filename has exactly 3 parts (TC, ID, and suffix)

Lines 47-50: Extract Parts
--------------------------
tc_part = parts[0]  # TC
tc_id_part = parts[1]  # 01_12345
suffix = parts[2].replace('.json', '')  # deny, bypass, market, date
- Extracts the test case part (TC)
- Extracts the test case ID part (01_12345, etc.)
- Extracts the suffix, removing the '.json' extension

Lines 52-56: Advanced Suffix Mapping
------------------------------------
mapped_suffix = suffix
for category in suffix_mapping.values():
    if suffix in category:
        mapped_suffix = category[suffix]
        break
- Searches through all categories in the nested mapping structure
- When a match is found, assigns the mapped value
- If no match is found, keeps the original suffix

Line 58: Create New Filename
----------------------------
new_filename = f"{tc_part}#{tc_id_part}#{edit_id}#{code}#{mapped_suffix}.json"
- Creates new filename using the template: TC#XX_XXXXX#rvn001#00W5#mapped_suffix.json

Lines 60-64: Print Conversion Info
----------------------------------
print(f"Current: {filename}")
print(f"Converting to new template...")
print(f"New:     {new_filename}")
print(f"Moving to: {dest_dir}")
print("-" * 40)
- Shows the current filename
- Indicates conversion process
- Shows the new filename
- Shows destination directory
- Creates a visual separator line (40 dashes)

Lines 66-67: Handle Invalid Format
---------------------------------
else:
    print(f"Warning: {filename} doesn't match expected format (needs exactly 3 parts)")
    continue
- Handles files that don't match the expected format
- Skips to the next file in the loop

Lines 69-70: Set File Paths
---------------------------
source_path = os.path.join(source_dir, filename)
dest_path = os.path.join(dest_dir, new_filename)
- Creates full source file path
- Creates full destination file path

Lines 72-83: File Operations
-----------------------------
try:
    # Copy the file to destination with new name
    shutil.copy2(source_path, dest_path)
    print(f"✓ Successfully copied and renamed: {filename} → {new_filename}")
    
    # Remove the original file
    os.remove(source_path)
    print(f"✓ Removed original file: {filename}")
    
except Exception as e:
    print(f"✗ Error processing {filename}: {e}")
- Copies file to destination with new name
- Prints success message for copying
- Removes the original file
- Prints success message for removal
- Handles any errors that occur during the process

Lines 85-88: Completion Message
-------------------------------
print("\n" + "=" * 60)
print("Renaming and moving completed!")
print(f"Files moved to: {dest_dir}")
- Prints a blank line
- Creates a visual separator line (60 equal signs)
- Prints completion message
- Shows the destination directory

Lines 90-91: Main Execution
---------------------------
if __name__ == "__main__":
    rename_files()
- Runs the function when the script is executed directly
- Prevents the function from running if the script is imported as a module

SUMMARY
=======
This script renames JSON files from a 3-part format (TC#XX_XXXXX#suffix.json) to a more 
detailed 5-part naming convention (TC#XX_XXXXX#rvn001#00W5#mapped_suffix.json) by:

1. Reading files from a source directory
2. Parsing their current names into 3 components (TC, ID, suffix)
3. Applying advanced suffix mappings using a nested dictionary structure
4. Creating new names with additional parameters (edit_id, code)
5. Moving them to a destination directory
6. Cleaning up the original files

The script uses a sophisticated nested mapping system that categorizes suffixes into:
- **positive**: Limited Response test cases (deny → LR)
- **negative**: No Response test cases (bypass → NR)  
- **Exclusion**: Exception test cases (market → EX, date → EX)

The lookup algorithm searches through all categories to find the correct mapping,
allowing multiple suffixes to map to the same output suffix.

EXAMPLE TRANSFORMATION:
- Input:  TC#01_12345#deny.json
- Output: TC#01_12345#rvn001#00W5#LR.json

Where:
- TC: Test case identifier
- 01_12345: Test case ID
- deny: Original suffix
- rvn001: Edit ID
- 00W5: Code
- LR: Mapped suffix (deny → LR via positive category)

MAPPING EXAMPLES:
- deny → LR (positive category)
- bypass → NR (negative category)
- market → EX (Exclusion category)
- date → EX (Exclusion category)
